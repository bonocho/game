<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
        }
        #gameCanvas {
            border: 1px solid #000;
            margin-bottom: 20px;
        }
        #scoreBoard {
            font-size: 20px;
        }
        #message {
            font-size: 24px;
            color: red;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <div id="scoreBoard">
        <span id="score">Score: 0</span>
        <span id="timer">Time: 30</span>
    </div>
    <div id="message">다음 라운드로 넘어갑니다...</div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');

        const tileSize = 40;
        const rows = 10;
        const cols = 10;
        const initialTime = 30; // 제한 시간(초)

        let score = 0;
        let timeLeft = initialTime;
        let timerInterval;

        const player = {
            x: 0,
            y: 0,
            color: 'blue'
        };

        const goal = {
            x: 9,
            y: 9,
            color: 'green'
        };

        let walls = [];
        let numberOfWalls = 20; // 초기 벽의 개수

        function generateWalls() {
            walls = [];
            while (walls.length < numberOfWalls) {
                const wall = {
                    x: Math.floor(Math.random() * cols),
                    y: Math.floor(Math.random() * rows)
                };

                // 플레이어와 목표 지점, 그리고 기존 벽과 겹치지 않도록 함
                if ((wall.x !== player.x || wall.y !== player.y) &&
                    (wall.x !== goal.x || wall.y !== goal.y) &&
                    !walls.some(w => w.x === wall.x && w.y === wall.y)) {
                    walls.push(wall);
                }
            }
            ensurePath();
        }

        function ensurePath() {
            // 시작 지점부터 도착 지점까지의 경로를 확보하기 위해 DFS(깊이 우선 탐색) 사용
            let stack = [{x: player.x, y: player.y}];
            let visited = Array.from({length: rows}, () => Array(cols).fill(false));
            visited[player.x][player.y] = true;

            const directions = [
                {dx: 0, dy: -1}, // 위
                {dx: 0, dy: 1},  // 아래
                {dx: -1, dy: 0}, // 왼쪽
                {dx: 1, dy: 0}   // 오른쪽
            ];

            while (stack.length > 0) {
                let {x, y} = stack.pop();

                for (let {dx, dy} of directions) {
                    let nx = x + dx;
                    let ny = y + dy;

                    if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !visited[nx][ny]) {
                        visited[nx][ny] = true;
                        stack.push({x: nx, y: ny});

                        // 경로에 벽이 있으면 제거
                        walls = walls.filter(wall => !(wall.x === nx && wall.y === ny));

                        if (nx === goal.x && ny === goal.y) {
                            return;
                        }
                    }
                }
            }
        }

        function drawTile(x, y, color) {
            context.fillStyle = color;
            context.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
        }

        function drawMaze() {
            context.clearRect(0, 0, canvas.width, canvas.height);
            drawTile(player.x, player.y, player.color);
            drawTile(goal.x, goal.y, goal.color);

            walls.forEach(wall => {
                drawTile(wall.x, wall.y, 'black');
            });
        }

        function movePlayer(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;

            if (newX >= 0 && newX < cols && newY >= 0 && newY < rows) {
                const isWall = walls.some(wall => wall.x === newX && wall.y === newY);

                if (!isWall) {
                    player.x = newX;
                    player.y = newY;

                    if (player.x === goal.x && player.y === goal.y) {
                        score += 10; // 도착 시 점수 추가
                        updateScoreBoard();
                        showNextRoundMessage();
                    }
                }
            }

            drawMaze();
        }

        function updateScoreBoard() {
            document.getElementById('score').textContent = `Score: ${score}`;
            document.getElementById('timer').textContent = `Time: ${timeLeft}`;
        }

        function resetGame() {
            player.x = 0;
            player.y = 0;
            numberOfWalls += 5; // 난이도 증가: 벽의 개수를 5개씩 증가시킴
            timeLeft = initialTime; // 제한 시간 초기화
            clearInterval(timerInterval);
            startTimer();
            generateWalls();
            drawMaze();
        }

        function showNextRoundMessage() {
            const messageElement = document.getElementById('message');
            messageElement.style.display = 'block';
            setTimeout(() => {
                messageElement.style.display = 'none';
                resetGame();
            }, 2000); // 2초 후에 게임을 리셋
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                timeLeft--;
                updateScoreBoard();

                if (timeLeft <= 0) {
                    alert('Time\'s up! You lose.');
                    clearInterval(timerInterval);
                    resetGame();
                }
            }, 1000);
        }

        document.addEventListener('keydown', event => {
            switch (event.key) {
                case 'ArrowUp':
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                    movePlayer(1, 0);
                    break;
            }
        });

        generateWalls();
        drawMaze();
        startTimer();
    </script>
</body>
</html>
